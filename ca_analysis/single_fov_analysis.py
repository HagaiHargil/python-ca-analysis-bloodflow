import numpy as np
import pandas as pd
import xarray as xr
import attr
from attr.validators import instance_of
import pathlib

from analog_trace import AnalogTraceAnalyzer
from fluo_metadata import FluoMetadata


@attr.s(slots=True)
class SingleFovParser:
    """ Analyze a single FOV with fluorescent and analog data """

    analog_fname = attr.ib(validator=instance_of(pathlib.Path))
    fluo_fname = attr.ib(validator=instance_of(pathlib.Path))
    metadata = attr.ib(validator=instance_of(FluoMetadata))
    analog_analyzed = attr.ib(init=False, repr=False)  # AnalogTraceAnalyzer instance
    all_fluo_results = attr.ib(init=False, repr=False)  # all data generated by CaImAn
    fluo_trace = attr.ib(init=False, repr=False)  # The specific dF/F trace of that file
    fluo_analyzed = attr.ib(init=False)  # DataArray with the different slices of run, stim and dF/F

    def parse(self):
        """ Main method to parse a single duo of analog and fluorescent data """
        self.all_fluo_results = np.load(str(self.fluo_fname))
        self.fluo_trace = self.all_fluo_results['F_dff']
        try:
            if not self.fluo_trace:  # no cells detected
                self.fluo_trace = np.array([])
        except ValueError:
            pass
        analog_data = pd.read_table(self.analog_fname, header=None,
                                    names=['stimulus', 'run'], index_col=False)
        self.analog_analyzed = AnalogTraceAnalyzer(tif_filename=str(self.analog_fname), 
                                                   analog_trace=analog_data,
                                                   framerate=self.metadata.fps,
                                                   num_of_channels=self.metadata.num_of_channels,
                                                   start_time=self.metadata.start_time,
                                                   timestamps=self.metadata.timestamps)
        self.analog_analyzed.run()
        if self.fluo_trace.shape[0] != 0:
            self.fluo_analyzed = self.analog_analyzed * self.fluo_trace
        else:
            self.fluo_analyzed = None

    def add_metadata_and_serialize(self):
        """ 
        Write a full DataArray to disk after parsing the FOV, if it doesn't exist yet.
        The new coordinates order is (epoch, neuron, time, mouse_id, fov, condition).
        """
        try:
            _ = next(pathlib.Path(self.metadata.fname).parent\
                .glob(str(self.metadata.fname.name)[:-4] + '.nc'))
        except StopIteration:
            try:
                raw_data = self.fluo_analyzed.data
            except AttributeError:
                print("No fluorescent data in this FOV.")
                return
            print("Writing new NetCDF to disk.")
            raw_data = raw_data[..., np.newaxis, np.newaxis, np.newaxis]
            assert len(raw_data.shape) == 6
            coords = {}
            coords['epoch'] = self.fluo_analyzed['epoch'].values
            coords['neuron'] = self.fluo_analyzed['neuron'].values
            coords['time'] = self.metadata.timestamps
            coords['mouse_id'] = np.array([self.metadata.mouse_id])
            coords['fov'] = np.array([self.metadata.fov])
            coords['condition'] = np.array([self.metadata.condition])
            metadata = {'day': np.array([self.metadata.day]),
                        'fps': self.metadata.fps,
                        'stim_window': self.fluo_analyzed.attrs['stim_window']}
            darr = xr.DataArray(raw_data, coords=coords, dims=coords.keys(),
                                attrs=metadata)
            darr.to_netcdf(str(self.metadata.fname)[:-4] + ".nc", mode='w',
                           format='NETCDF3_64BIT')  # TODO: compress