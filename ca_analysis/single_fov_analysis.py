import numpy as np
import pandas as pd
import xarray as xr
import attr
from attr.validators import instance_of
import pathlib

from ca_analysis.analog_trace import AnalogTraceAnalyzer
from ca_analysis.fluo_metadata import FluoMetadata


@attr.s(slots=True)
class SingleFovParser:
    """ Analyze a single FOV with fluorescent and analog data """

    analog_fname = attr.ib(validator=instance_of(pathlib.Path))
    results_fname = attr.ib(validator=instance_of(pathlib.Path))
    metadata = attr.ib(validator=instance_of(FluoMetadata))
    analog_analyzed = attr.ib(init=False, repr=False)  # AnalogTraceAnalyzer instance
    all_fluo_results = attr.ib(init=False, repr=False)  # all data generated by CaImAn
    fluo_trace = attr.ib(init=False, repr=False)  # The specific dF/F trace of that file
    fluo_analyzed = attr.ib(init=False)  # DataArray with the different slices of run, stim and dF/F

    def parse(self):
        """ Main method to parse a single duo of analog and fluorescent data """
        with np.load(str(self.results_fname), 'r+') as self.all_fluo_results:
            self.fluo_trace = self.all_fluo_results['F_dff']
            faulty_idx = self._find_faulty_cells(self.fluo_trace)
            self.fluo_trace = self._filter_faulty_cells(faulty_idx, self.all_fluo_results)
        try:
            if not self.fluo_trace:  # no cells detected
                self.fluo_trace = np.array([])
        except ValueError:
            pass
        analog_data = pd.read_table(self.analog_fname, header=None,
                                    names=['stimulus', 'run'], index_col=False)
        self.analog_analyzed = AnalogTraceAnalyzer(tif_filename=str(self.analog_fname), 
                                                   analog_trace=analog_data,
                                                   framerate=self.metadata.fps,
                                                   start_time=self.metadata.start_time,
                                                   timestamps=self.metadata.timestamps)
        self.analog_analyzed.run()
        if self.fluo_trace.shape[0] != 0:
            self.fluo_analyzed = self.analog_analyzed * self.fluo_trace
        else:
            self.fluo_analyzed = None

    def add_metadata_and_serialize(self):
        """ 
        Write a full DataArray to disk after parsing the FOV, if it doesn't exist yet.
        The new coordinates order is (epoch, neuron, time, mouse_id, fov, condition).
        """
        try:
            _ = next(pathlib.Path(self.metadata.fname).parent\
                .glob(str(self.metadata.fname.name)[:-4] + '.nc'))
        except StopIteration:
            try:
                raw_data = self.fluo_analyzed.data
            except AttributeError:
                print("No fluorescent data in this FOV.")
                return
            print("Writing new NetCDF to disk.")
            raw_data = raw_data[..., np.newaxis, np.newaxis, np.newaxis]
            assert len(raw_data.shape) == 6
            coords = {}
            coords['epoch'] = self.fluo_analyzed['epoch'].values
            coords['neuron'] = self.fluo_analyzed['neuron'].values
            coords['time'] = self.metadata.timestamps
            coords['mouse_id'] = np.array([self.metadata.mouse_id])
            coords['fov'] = np.array([self.metadata.fov])
            coords['condition'] = np.array([self.metadata.condition])
            metadata = {'day': np.array([self.metadata.day]),
                        'fps': self.metadata.fps,
                        'stim_window': self.fluo_analyzed.attrs['stim_window']}
            darr = xr.DataArray(raw_data, coords=coords, dims=coords.keys(),
                                attrs=metadata)
            darr.to_netcdf(str(self.metadata.fname)[:-4] + ".nc", mode='w',
                           format='NETCDF3_64BIT')  # TODO: compress

    def _find_faulty_cells(self, data: np.ndarray) -> np.ndarray:
        """ Analyzed the recorded dFF array and finds any cells with
        unusual dFF values. Returns their indices, to be filtered out later. """
        idx = data[1]
        return idx

    def _filter_faulty_cells(self, indices: np.ndarray, f: dict) -> np.ndarray:
        """ Removes from the main dFF array the faulty cells detected. Also
        Writes back to disk (the input dictionary) the faulty indices. """
        pass


if __name__ == '__main__':
    folder = pathlib.Path(r'/data/David/NEW_crystal_skull_TAC_161018/DAY_7_ALL/619_HYPO_DAY_7/')
    fov = 5  # FOV2 in 149_HYPO_7 (~37) and 3 in 619 (59) need to run
    analog_fname = next(folder.glob(f'6*{fov}*01_analog.txt'))
    results_fname = next(folder.glob(f'6*{fov}*01_CHANNEL_1_results.npz'))
    orig_fname = next(folder.glob(f'6*{fov}*01.tif'))
    meta = FluoMetadata(orig_fname)
    meta.get_metadata()
    sfov = SingleFovParser(analog_fname, results_fname, meta)
    sfov.parse()
